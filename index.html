<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#F7F9F7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>MochiDrop ü¶•</title>
    
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="https://cdn-icons-png.flaticon.com/512/3750/3750019.png">
    
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Quicksand:wght@500;600;700&display=swap');
        
        :root {
            /* --- Lumina Premium ÈÖçËâ≤ --- */
            --bg-page: #F7F9F7;
            --bg-card: #FFFFFF;
            --text-main: #2C3E50;
            --text-sub: #95A5A6;
            --accent-primary: #76A665;
            --accent-light: #E8F5E9;
            --accent-hover: #639252;
            --radius-card: 24px;
            --radius-btn: 16px;
            
            --shadow-float: 0 15px 35px -5px rgba(118, 166, 101, 0.15), 0 5px 15px -8px rgba(0,0,0,0.05);
            --shadow-inner: inset 0 2px 4px rgba(0,0,0,0.02);
        }

        body { 
            font-family: 'Quicksand', -apple-system, BlinkMacSystemFont, sans-serif; 
            background-color: var(--bg-page);
            color: var(--text-main);
            margin: 0; display: flex; flex-direction: column; align-items: center; 
            min-height: 100vh; overflow-x: hidden; -webkit-tap-highlight-color: transparent; 
            padding-top: 80px; padding-bottom: 40px;
        }

        .navbar {
            position: fixed; top: 0; left: 0; width: 100%; height: 64px;
            background: rgba(247, 249, 247, 0.85);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            display: flex; align-items: center; justify-content: center;
            z-index: 1000;
        }
        .navbar-title {
            font-family: 'Fredoka One', cursive; 
            color: var(--accent-primary); font-size: 1.4rem; 
            display: flex; align-items: center; gap: 8px; letter-spacing: 0.5px;
        }
        .navbar-icon { width: 32px; height: 32px; }

        .card { 
            width: 88%; max-width: 420px; 
            background: var(--bg-card);
            border-radius: var(--radius-card); 
            padding: 24px; 
            box-shadow: var(--shadow-float);
            margin-bottom: 24px;
            transition: transform 0.2s ease;
        }
        
        .card-label {
            font-size: 0.75rem; color: var(--text-sub); font-weight: 700; 
            text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 16px;
            display: block; text-align: left;
        }

        /* Ë∫´‰ªΩÂç°Áâá (Â∑¶ÂõæÂè≥Êñá) */
        .identity-layout { display: flex; align-items: center; gap: 20px; }
        .qr-container {
            flex-shrink: 0; width: 100px; height: 100px;
            background: var(--bg-page); border-radius: 18px; padding: 8px;
            display: flex; align-items: center; justify-content: center;
        }
        #qrcode img { display: block; width: 100%; height: auto; }
        .info-container {
            flex-grow: 1; display: flex; flex-direction: column; justify-content: center;
            text-align: left; overflow: hidden;
        }
        .id-label { font-size: 0.8rem; color: var(--text-sub); margin-bottom: 4px; }
        .id-value {
            font-family: 'Quicksand', monospace;
            font-size: 1.2rem; font-weight: 700; color: var(--text-main);
            word-break: break-all; line-height: 1.3;
        }
        .status-badge {
            display: inline-flex; align-items: center; gap: 6px;
            margin-top: 8px; font-size: 0.75rem; 
            color: var(--accent-primary); font-weight: 600;
            background: var(--accent-light); padding: 4px 10px; border-radius: 20px;
            align-self: flex-start;
        }
        .status-dot { width: 8px; height: 8px; background: var(--accent-primary); border-radius: 50%; }

        /* ËøûÊé•Âç°Áâá */
        .input-wrapper {
            position: relative; margin-bottom: 12px;
            display: flex; align-items: center;
            background: var(--bg-page); border-radius: var(--radius-btn);
            padding: 4px 6px 4px 16px;
            box-shadow: var(--shadow-inner);
            border: 1px solid transparent; transition: 0.3s;
        }
        .input-wrapper:focus-within { background: #FFF; border-color: var(--accent-primary); box-shadow: 0 0 0 3px rgba(118, 166, 101, 0.15); }
        input[type="text"] {
            flex: 1; border: none; background: transparent; outline: none;
            font-size: 1rem; font-weight: 600; color: var(--text-main);
            padding: 12px 0; font-family: 'Quicksand', sans-serif;
        }
        input::placeholder { color: #BDC3C7; font-weight: 500; }
        .btn-scan-mini {
            width: 40px; height: 40px; border-radius: 12px;
            background: #FFF; border: none; cursor: pointer;
            font-size: 1.2rem; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); color: #555; transition: 0.2s;
        }
        .btn-scan-mini:active { transform: scale(0.9); background: var(--accent-light); }
        .btn-primary {
            width: 100%; padding: 16px; border: none; border-radius: var(--radius-btn);
            background: var(--accent-primary); color: white;
            font-size: 1rem; font-weight: 700; cursor: pointer;
            box-shadow: 0 4px 15px rgba(118, 166, 101, 0.4);
            transition: all 0.2s ease; letter-spacing: 0.5px;
        }
        .btn-primary:active { transform: scale(0.98); background: var(--accent-hover); box-shadow: none; }

        /* --- ‰º†ËæìÂå∫Âüü (Â¢ûÂä†ÊãñÊãΩ‰∫§‰∫í) --- */
        .upload-zone {
            border: 2px dashed #D6E4D0; border-radius: var(--radius-card);
            background: #FAFCFA; padding: 40px 20px; cursor: pointer;
            display: flex; flex-direction: column; align-items: center;
            transition: 0.3s;
        }
        /* ÊãñÊãΩÊÇ¨ÂÅúÁä∂ÊÄÅ */
        .upload-zone.drag-over {
            background: var(--accent-light);
            border-color: var(--accent-primary);
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(118, 166, 101, 0.2);
        }
        
        .upload-icon { font-size: 2.2rem; color: var(--accent-primary); margin-bottom: 12px; opacity: 0.8;}
        .upload-text { font-size: 0.95rem; color: var(--text-sub); font-weight: 600; }
        .upload-subtext { font-size: 0.75rem; color: var(--text-sub); opacity: 0.6; margin-top: 5px;}

        .file-list { list-style: none; padding: 0; margin: 20px 0 0 0; max-height: 200px; overflow-y: auto;}
        .file-item { display: flex; align-items: center; gap: 12px; padding: 12px; border-bottom: 1px solid #F0F0F0; }
        .file-item:last-child { border-bottom: none; }
        .file-icon { font-size: 1.2rem; }
        .file-name { flex: 1; font-size: 0.9rem; font-weight: 600; color: var(--text-main); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; text-align: left;}
        .file-status { font-size: 0.8rem; color: var(--text-sub); }
        .file-item.done .file-status { color: var(--accent-primary); font-weight: bold; }

        .download-btn {
            display: flex; align-items: center; gap: 10px;
            background: #FFF; border: 1px solid var(--accent-primary);
            color: var(--accent-primary); padding: 12px 16px;
            border-radius: 12px; text-decoration: none; margin-bottom: 10px;
            font-weight: 700; font-size: 0.9rem; transition: 0.2s;
        }
        .download-btn:active { background: var(--accent-light); }

        .progress-bar-container { width: 100%; height: 6px; background: #EDF2ED; border-radius: 10px; overflow: hidden; margin-top: 20px; display: none;}
        .progress-bar-fill { height: 100%; width: 0%; background: var(--accent-primary); border-radius: 10px; transition: width 0.2s; }
        .progress-text { font-size: 0.75rem; color: var(--text-sub); margin-top: 8px; text-align: right;}

        #status-toast {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(44, 62, 80, 0.9); color: white;
            padding: 12px 24px; border-radius: 50px;
            font-size: 0.9rem; font-weight: 600;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            backdrop-filter: blur(10px); display: none; z-index: 2000;
            white-space: nowrap;
        }

        #scan-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px);
            z-index: 9999; display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        #reader { width: 80vw; max-width: 350px; border-radius: 24px; overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.2); }
        .btn-close-scan {
            margin-top: 40px; width: 50px; height: 50px; border-radius: 50%;
            background: #F1F1F1; color: #333; border: none; font-size: 1.2rem;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
        }
    </style>
</head>
<body>

    <div class="navbar">
        <div class="navbar-title">
            <img src="https://cdn-icons-png.flaticon.com/512/3750/3750019.png" class="navbar-icon">
            SlothDrop
        </div>
    </div>

    <div class="card">
        <span class="card-label">MY IDENTITY</span>
        <div class="identity-layout">
            <div class="qr-container" id="qrcode"></div>
            <div class="info-container">
                <div class="id-label">Device ID</div>
                <div class="id-value" id="my-id">...</div>
                <div class="status-badge">
                    <span class="status-dot"></span>
                    <span id="connection-status">Ready</span>
                </div>
            </div>
        </div>
    </div>

    <div class="card" id="connect-panel">
        <span class="card-label">CONNECT DEVICE</span>
        <div class="input-wrapper">
            <input type="text" id="friend-id" placeholder="Enter Friend's ID" autocomplete="off">
            <button class="btn-scan-mini" onclick="startScan()">üì∑</button>
        </div>
        <button class="btn-primary" onclick="connectToFriend()">Connect</button>
    </div>

    <div class="card" id="transfer-panel" style="display:none;">
        <span class="card-label">TRANSFER</span>
        
        <div id="send-section">
            <label for="file-input" class="upload-zone" id="drop-zone">
                <div class="upload-icon">üìÇ</div>
                <div class="upload-text">Click or Drag Files Here</div>
                <div class="upload-subtext">Support folders drag & drop</div>
            </label>
            <input type="file" id="file-input" style="display:none" multiple onchange="handleFileSelect(this)">
            
            <ul id="queue-list" class="file-list"></ul>
            <button class="btn-primary" onclick="processQueue()" id="send-btn" style="display:none; margin-top:20px;">Send Files üöÄ</button>
        </div>

        <div id="receive-section" style="display:none; margin-top:20px;">
             <span class="card-label" style="color:var(--accent-primary)">RECEIVED FILES</span>
             <div id="received-list"></div>
        </div>

        <div class="progress-bar-container" id="progress-area">
            <div class="progress-bar-fill" id="progress-bar"></div>
        </div>
        <div class="progress-text" id="progress-text"></div>
    </div>

    <div id="status-toast"></div>
    <div id="scan-overlay">
        <div id="reader"></div>
        <button class="btn-close-scan" onclick="stopScan()">‚úï</button>
    </div>

    <script>
        let peer = null; let conn = null; let html5QrCode = null; 
        const CHUNK_SIZE = 4 * 1024; 
        const MAX_BUFFERED_AMOUNT = 32 * 1024; 
        let sendQueue = []; let wakeLock = null;

        const ui = {
            myId: document.getElementById('my-id'), 
            toast: document.getElementById('status-toast'),
            statusText: document.getElementById('connection-status'),
            panels: { connect: document.getElementById('connect-panel'), transfer: document.getElementById('transfer-panel') },
            scan: { overlay: document.getElementById('scan-overlay') },
            input: document.getElementById('friend-id'),
            send: { btn: document.getElementById('send-btn'), list: document.getElementById('queue-list'), section: document.getElementById('send-section') },
            receive: { section: document.getElementById('receive-section'), list: document.getElementById('received-list') },
            progress: { area: document.getElementById('progress-area'), bar: document.getElementById('progress-bar'), text: document.getElementById('progress-text') },
            dropZone: document.getElementById('drop-zone')
        };

        // --- Core Logic ---
        try {
            peer = new Peer(null, { debug: 1 });
            peer.on('open', id => {
                ui.myId.innerText = id;
                ui.statusText.innerText = "Online";
                const qrContainer = document.getElementById("qrcode"); qrContainer.innerHTML = "";
                setTimeout(() => {
                    new QRCode(qrContainer, { text: id, width: 84, height: 84, colorDark : "#2C3E50", colorLight : "#F7F9F7", correctLevel : QRCode.CorrectLevel.L });
                }, 100);
            });
            peer.on('error', err => { showToast("Error: " + err.type); ui.statusText.innerText = "Offline"; });
            peer.on('connection', c => { conn = c; setupConnection(); });
        } catch(e) { alert("Init Failed"); }

        async function requestWakeLock() { try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); } catch (err) {} }
        function releaseWakeLock() { if (wakeLock) { wakeLock.release(); wakeLock = null; } }

        // --- Drag & Drop + Folder Recursion Logic ---
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            ui.dropZone.addEventListener(eventName, preventDefaults, false);
        });
        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            ui.dropZone.addEventListener(eventName, () => ui.dropZone.classList.add('drag-over'), false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            ui.dropZone.addEventListener(eventName, () => ui.dropZone.classList.remove('drag-over'), false);
        });

        ui.dropZone.addEventListener('drop', handleDrop, false);

        async function handleDrop(e) {
            let dt = e.dataTransfer;
            // Modern Directory scanning
            if (dt.items) {
                let items = dt.items;
                for (let i = 0; i < items.length; i++) {
                    let item = items[i].webkitGetAsEntry ? items[i].webkitGetAsEntry() : items[i].getAsEntry ? items[i].getAsEntry() : null;
                    if (item) {
                        await traverseFileTree(item);
                    } else if (items[i].kind === 'file') {
                        let file = items[i].getAsFile();
                        addFileToQueue(file);
                    }
                }
            } else {
                // Fallback for simple file drop
                handleFiles(dt.files);
            }
            updateSendUI();
        }

        async function traverseFileTree(item, path = "") {
            if (item.isFile) {
                // Get file
                return new Promise(resolve => {
                    item.file(file => {
                        addFileToQueue(file);
                        resolve();
                    });
                });
            } else if (item.isDirectory) {
                // Get folder contents
                let dirReader = item.createReader();
                return new Promise(resolve => {
                    dirReader.readEntries(async entries => {
                        for (let entry of entries) {
                            await traverseFileTree(entry, path + item.name + "/");
                        }
                        resolve();
                    });
                });
            }
        }

        function addFileToQueue(file) {
            sendQueue.push(file);
        }

        function handleFiles(files) {
            for (let i = 0; i < files.length; i++) {
                addFileToQueue(files[i]);
            }
        }

        function updateSendUI() {
            if (sendQueue.length > 0) {
                renderQueueList();
                ui.send.btn.style.display = 'block'; 
                ui.send.btn.innerText = `Send ${sendQueue.length} Files`;
            }
        }

        // --- Standard File Input ---
        function handleFileSelect(input) {
            if (input.files && input.files.length > 0) {
                handleFiles(input.files);
                updateSendUI();
            }
        }

        function renderQueueList() {
            ui.send.list.innerHTML = "";
            sendQueue.forEach((file, index) => {
                const li = document.createElement('li'); li.className = 'file-item'; li.id = `file-item-${index}`;
                li.innerHTML = `<span class="file-icon">üìÑ</span><span class="file-name">${file.name}</span><span class="file-status">Wait</span>`;
                ui.send.list.appendChild(li);
            });
        }

        // --- Common Logic ---
        function startScan() {
            ui.scan.overlay.style.display = "flex";
            html5QrCode = new Html5Qrcode("reader");
            html5QrCode.start({ facingMode: "environment" }, { fps: 15, qrbox: { width: 250, height: 250 } },
                (decodedText) => { ui.input.value = decodedText; stopScan(); showToast("ID Scanned"); if(navigator.vibrate) navigator.vibrate(200); },
                () => {}).catch(err => { showToast("Camera Error"); stopScan(); });
        }
        function stopScan() {
            if(html5QrCode && html5QrCode.isScanning) html5QrCode.stop().then(() => { html5QrCode.clear(); ui.scan.overlay.style.display = "none"; }).catch(() => { ui.scan.overlay.style.display = "none"; });
            else ui.scan.overlay.style.display = "none";
        }

        function connectToFriend() {
            const friendId = ui.input.value.trim();
            if(!friendId) return showToast("Please enter ID");
            conn = peer.connect(friendId, { reliable: true });
            showToast("Connecting...");
            setupConnection();
        }

        function setupConnection() {
            conn.on('open', () => { 
                showToast("Connected!"); 
                ui.statusText.innerText = "Linked";
                ui.panels.connect.style.display = 'none'; 
                ui.panels.transfer.style.display = 'block'; 
            });
            conn.on('close', () => { showToast("Disconnected"); setTimeout(() => location.reload(), 2000); });
            conn.on('data', handleDataReceived);
        }

        let incomingFile = { buffer: [], receivedSize: 0, meta: null };
        function handleDataReceived(data) {
            if (data instanceof ArrayBuffer || data instanceof Uint8Array) {
                if(!incomingFile.meta) return;
                const chunk = new Uint8Array(data);
                incomingFile.buffer.push(chunk);
                incomingFile.receivedSize += chunk.byteLength;
                if (incomingFile.receivedSize % (CHUNK_SIZE * 20) === 0 || incomingFile.receivedSize === incomingFile.meta.fileSize) {
                    updateProgress(Math.floor((incomingFile.receivedSize / incomingFile.meta.fileSize) * 100));
                }
            } else if (data.type) {
                if (data.type === 'header') {
                    incomingFile.buffer = []; incomingFile.receivedSize = 0; incomingFile.meta = data;
                    ui.receive.section.style.display = 'block'; ui.progress.area.style.display = 'block';
                    showToast(`Receiving: ${data.fileName}`);
                    requestWakeLock();
                } else if (data.type === 'end') {
                    updateProgress(100);
                    createDownloadButton(incomingFile.buffer, incomingFile.meta);
                    showToast("Download Ready");
                    incomingFile.buffer = []; incomingFile.meta = null;
                    releaseWakeLock();
                }
            }
        }

        function createDownloadButton(buffers, meta) {
            const blob = new Blob(buffers, { type: meta.fileType || 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const btn = document.createElement('a');
            btn.href = url; btn.download = meta.fileName; btn.className = 'download-btn';
            btn.innerHTML = `<span>üì• ${meta.fileName}</span>`;
            ui.receive.list.prepend(btn);
        }

        async function processQueue() {
            if (!conn || sendQueue.length === 0) return;
            ui.send.btn.style.display = 'none'; ui.progress.area.style.display = 'block'; requestWakeLock();
            for (let i = 0; i < sendQueue.length; i++) {
                const file = sendQueue[i]; const li = document.getElementById(`file-item-${i}`);
                showToast(`Sending ${i+1}/${sendQueue.length}`);
                li.querySelector('.file-status').innerText = "Sending...";
                await sendSingleFile(file);
                li.classList.add('done'); li.querySelector('.file-status').innerText = "Done";
                await new Promise(r => setTimeout(r, 1000));
            }
            showToast("All Sent!"); setTimeout(() => { ui.progress.area.style.display = 'none'; }, 1000); releaseWakeLock();
        }
        
        async function sendSingleFile(file) {
            conn.send({ type: 'header', fileName: file.name, fileType: file.type, fileSize: file.size });
            let offset = 0;
            while (offset < file.size) {
                if (conn.dataChannel.bufferedAmount > MAX_BUFFERED_AMOUNT) { await new Promise(r => setTimeout(r, 50)); continue; }
                const chunk = file.slice(offset, offset + CHUNK_SIZE);
                const buffer = await chunk.arrayBuffer();
                conn.send(new Uint8Array(buffer));
                offset += CHUNK_SIZE;
                if (offset % (CHUNK_SIZE * 20) === 0) updateProgress(Math.floor((offset / file.size) * 100));
                await new Promise(r => setTimeout(r, 2));
            }
            conn.send({ type: 'end' });
        }
        
        function updateProgress(percent) { 
            ui.progress.bar.style.width = percent + '%'; 
            ui.progress.text.innerText = percent + '%'; 
        }
        
        function showToast(text) { 
            ui.toast.innerText = text; 
            ui.toast.style.display = 'block'; 
            ui.toast.style.animation = 'pop 0.3s ease';
            setTimeout(() => { ui.toast.style.display = 'none'; }, 3000); 
        }
    </script>
</body>
</html>
